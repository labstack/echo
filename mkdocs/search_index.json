{
    "docs": [
        {
            "location": "/", 
            "text": "Echo\n\n\nA fast and unfancy micro web framework for Golang.\n\n\n\n\nFeatures\n\n\n\n\nFast HTTP router which smartly prioritize routes.\n\n\nExtensible middleware, supports:\n\n\necho.MiddlewareFunc\n\n\nfunc(echo.HandlerFunc) echo.HandlerFunc\n\n\necho.HandlerFunc\n\n\nfunc(*echo.Context) error\n\n\nfunc(http.Handler) http.Handler\n\n\nhttp.Handler\n\n\nhttp.HandlerFunc\n\n\nfunc(http.ResponseWriter, *http.Request)\n\n\n\n\n\n\nExtensible handler, supports:\n\n\necho.HandlerFunc\n\n\nfunc(*echo.Context) error\n\n\nhttp.Handler\n\n\nhttp.HandlerFunc\n\n\nfunc(http.ResponseWriter, *http.Request)\n\n\n\n\n\n\nSub-router/Groups\n\n\nHandy encoding/decoding functions.\n\n\nBuild-in support for:\n\n\nStatic files\n\n\nWebSocket\n\n\n\n\n\n\nAPI to serve index and favicon.\n\n\nCentralized HTTP error handling.\n\n\nCustomizable request binding function.\n\n\nCustomizable response rendering function, allowing you to use any HTML template engine.\n\n\n\n\nPerformance\n\n\n\n\n\nGetting Started\n\n\nInstallation\n\n\n$ go get github.com/labstack/echo\n\n\n\n\nHello, World!\n\n\nCreate \nserver.go\n with the following content\n\n\npackage main\n\nimport (\n    \nnet/http\n\n\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n)\n\n// Handler\nfunc hello(c *echo.Context) error {\n    return c.String(http.StatusOK, \nHello, World!\\n\n)\n}\n\nfunc main() {\n    // Echo instance\n    e := echo.New()\n\n    // Middleware\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    // Routes\n    e.Get(\n/\n, hello)\n\n    // Start server\n    e.Run(\n:1323\n)\n}\n\n\n\n\necho.New()\n returns a new instance of Echo.\n\n\ne.Use(mw.Logger())\n adds logging middleware to the chain. It logs every HTTP request\nmade to the server, producing output\n\n\n2015/06/07 18:16:16 GET / 200 13.238\u00b5s 14\n\n\n\n\ne.Get(\"/\", hello)\n Registers hello handler for HTTP method \nGET\n and path \n/\n, so\nwhenever server receives an HTTP request at \n/\n, hello function is called.\n\n\nIn hello handler \nc.String(http.StatusOK, \"Hello, World!\\n\")\n sends a text/plain\nHTTP response to the client with 200 status code.\n\n\ne.Run(\":1323\")\n Starts HTTP server at network address \n:1323\n.\n\n\nNow start the server using command\n\n\n$ go run server.go\n\n\n\n\nBrowse to \nhttp://localhost:1323\n and you should see\nHello, World! on the page.\n\n\nNext?\n\n\n\n\nBrowse \nrecipes\n\n\nHead over to \nGuide\n\n\n\n\nContribute\n\n\nUse issues for everything\n\n\n\n\nReport issues\n\n\nDiscuss before sending pull request\n\n\nSuggest new features\n\n\nImprove/fix documentation\n\n\n\n\nCredits\n\n\n\n\nVishal Rana\n - Author\n\n\nNitin Rana\n - Consultant\n\n\nContributors\n\n\n\n\nLicense\n\n\nMIT", 
            "title": "Home"
        }, 
        {
            "location": "/#echo", 
            "text": "A fast and unfancy micro web framework for Golang.", 
            "title": "Echo"
        }, 
        {
            "location": "/#features", 
            "text": "Fast HTTP router which smartly prioritize routes.  Extensible middleware, supports:  echo.MiddlewareFunc  func(echo.HandlerFunc) echo.HandlerFunc  echo.HandlerFunc  func(*echo.Context) error  func(http.Handler) http.Handler  http.Handler  http.HandlerFunc  func(http.ResponseWriter, *http.Request)    Extensible handler, supports:  echo.HandlerFunc  func(*echo.Context) error  http.Handler  http.HandlerFunc  func(http.ResponseWriter, *http.Request)    Sub-router/Groups  Handy encoding/decoding functions.  Build-in support for:  Static files  WebSocket    API to serve index and favicon.  Centralized HTTP error handling.  Customizable request binding function.  Customizable response rendering function, allowing you to use any HTML template engine.", 
            "title": "Features"
        }, 
        {
            "location": "/#performance", 
            "text": "", 
            "title": "Performance"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Installation  $ go get github.com/labstack/echo  Hello, World!  Create  server.go  with the following content  package main\n\nimport (\n     net/http \n\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n)\n\n// Handler\nfunc hello(c *echo.Context) error {\n    return c.String(http.StatusOK,  Hello, World!\\n )\n}\n\nfunc main() {\n    // Echo instance\n    e := echo.New()\n\n    // Middleware\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    // Routes\n    e.Get( / , hello)\n\n    // Start server\n    e.Run( :1323 )\n}  echo.New()  returns a new instance of Echo.  e.Use(mw.Logger())  adds logging middleware to the chain. It logs every HTTP request\nmade to the server, producing output  2015/06/07 18:16:16 GET / 200 13.238\u00b5s 14  e.Get(\"/\", hello)  Registers hello handler for HTTP method  GET  and path  / , so\nwhenever server receives an HTTP request at  / , hello function is called.  In hello handler  c.String(http.StatusOK, \"Hello, World!\\n\")  sends a text/plain\nHTTP response to the client with 200 status code.  e.Run(\":1323\")  Starts HTTP server at network address  :1323 .  Now start the server using command  $ go run server.go  Browse to  http://localhost:1323  and you should see\nHello, World! on the page.  Next?   Browse  recipes  Head over to  Guide", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#contribute", 
            "text": "Use issues for everything   Report issues  Discuss before sending pull request  Suggest new features  Improve/fix documentation", 
            "title": "Contribute"
        }, 
        {
            "location": "/#credits", 
            "text": "Vishal Rana  - Author  Nitin Rana  - Consultant  Contributors", 
            "title": "Credits"
        }, 
        {
            "location": "/#license", 
            "text": "MIT", 
            "title": "License"
        }, 
        {
            "location": "/guide/", 
            "text": "Guide\n\n\n\n\n\n\n\nInstallation\n\n\nEcho has been developed and tested using Go \n1.4.x\n\n\nInstall the latest version of Echo via \ngo get\n\n\n$ go get github.com/labstack/echo\n\n\n\n\nTo upgrade\n\n\n$ go get -u github.com/labstack/echo\n\n\n\n\nEcho follows \nsemantic versioning\n managed through GitHub releases.\nSpecific version of Echo can be installed using any \npackage manager\n.\n\n\nCustomization\n\n\nHTTP error handler\n\n\nEcho.SetHTTPErrorHandler(h HTTPErrorHandler)\n\n\nRegisters a custom \nEcho.HTTPErrorHandler\n.\n\n\nDefault handler rules\n\n\n\n\nIf error is of type \nEcho.HTTPError\n it sends HTTP response with status code \nHTTPError.Code\n\nand message \nHTTPError.Message\n.\n\n\nElse it sends \n500 - Internal Server Error\n.\n\n\nIf debug mode is enabled, it uses \nerror.Error()\n as status message.\n\n\n\n\nDebug\n\n\nEcho.SetDebug(on bool)\n\n\nEnables debug mode.\n\n\nRouting\n\n\nEcho's router is \nfast, optimized\n and\nflexible. It's based on \nradix tree\n\ndata structure which makes routing lookup really fast. It leverages\n\nsync pool\n to reuse memory and achieve\nzero dynamic memory allocation with no GC overhead.\n\n\nRoutes can be registered by specifying HTTP method, path and a handler. For example,\ncode below registers a route for method \nGET\n, path \n/hello\n and a handler which sends\n\nHello!\n HTTP response.\n\n\necho.Get(\n/hello\n, func(c *echo.Context) error {\n    return c.String(http.StatusOK, \nHello!\n)\n})\n\n\n\n\nEcho's default handler is \nfunc(*echo.Context) error\n where \necho.Context\n\nprimarily holds HTTP request and response objects. Echo also has a support for other\ntypes of handlers.\n\n\nPath parameter\n\n\nRequest path parameters can be extracted either by name \nEcho.Context.Param(name string) string\n\nor by index \nEcho.Context.P(i int) string\n. Getting parameter by index gives a\nslightly better performance.\n\n\necho.Get(\n/users/:id\n, func(c *echo.Context) error {\n    // By name\n    id := c.Param(\nid\n)\n\n    // By index\n    id := c.P(0)\n\n    return c.String(http.StatusOK, id)\n})\n\n\n\n\nMatch-any\n\n\nMatches zero or more characters in the path. For example, pattern \n/users/*\n will\nmatch\n\n\n\n\n/users/\n\n\n/users/1\n\n\n/users/1/files/1\n\n\n/users/anything...\n\n\n\n\nPath matching order\n\n\n\n\nStatic\n\n\nParam\n\n\nMatch any\n\n\n\n\nExample\n\n\ne.Get(\n/users/:id\n, func(c *echo.Context) error {\n    return c.String(http.StatusOK, \n/users/:id\n)\n})\n\ne.Get(\n/users/new\n, func(c *echo.Context) error {\n    return c.String(http.StatusOK, \n/users/new\n)\n})\n\ne.Get(\n/users/1/files/*\n, func(c *echo.Context) error {\n    return c.String(http.StatusOK, \n/users/1/files/*\n)\n})\n\n\n\n\nAbove routes would resolve in order\n\n\n\n\n/users/new\n\n\n/users/:id\n\n\n/users/1/files/*\n\n\n\n\nRoutes can be written in any order.\n\n\nGroup\n\n\nEcho.Group(prefix string, m ...Middleware) *Group\n\n\nRoutes with common prefix can be grouped to define a new sub-router with optional\nmiddleware. If middleware is passed to the function, it overrides parent middleware\n- helpful if you want a completely new middleware stack for the group. To add middleware\nlater you can use \nGroup.Use(m ...Middleware)\n. Groups can also be nested.\n\n\nIn the code below, we create an admin group which requires basic HTTP authentication\nfor routes \n/admin/*\n.\n\n\necho.Group(\n/admin\n)\ne.Use(mw.BasicAuth(func(usr, pwd string) bool {\n    if usr == \njoe\n \n pwd == \nsecret\n {\n        return true\n    }\n    return false\n}))\n\n\n\n\nURI building\n\n\nEcho.URI\n can be used generate URI for any handler with specified path parameters.\nIt's helpful to centralize all your URI patterns which ease in refactoring your\napplication.\n\n\necho.URI(h, 1)\n will generate \n/users/1\n for the route registered below\n\n\n// Handler\nh := func(*echo.Context) error {\n    return c.String(http.StatusOK, \nOK\n)\n}\n\n// Route\ne.Get(\n/users/:id\n, h)\n\n\n\n\nMiddleware\n\n\nMiddleware is function which is chained in the HTTP request-response cycle. Middleware\nhas access to the request and response objects which it utilizes to perform a specific\naction for example, logging every request. Echo supports variety of \nmiddleware\n.\n\n\nLogger\n\n\nLogs each HTTP request with method, path, status, response time and bytes served.\n\n\nExample\n\n\ne.Use(Logger())\n\n// Output: `2015/06/07 18:16:16 GET / 200 13.238\u00b5s 14`\n\n\n\n\nBasicAuth\n\n\nBasicAuth middleware provides an HTTP basic authentication.\n\n\n\n\nFor valid credentials it calls the next handler in the chain.\n\n\nFor invalid Authorization header it sends \"404 - Bad Request\" response.\n\n\nFor invalid credentials, it sends \"401 - Unauthorized\" response.\n\n\n\n\nExample\n\n\necho.Group(\n/admin\n)\ne.Use(mw.BasicAuth(func(usr, pwd string) bool {\n    if usr == \njoe\n \n pwd == \nsecret\n {\n        return true\n    }\n    return false\n}))\n\n\n\n\nGzip\n\n\nGzip middleware compresses HTTP response using gzip compression scheme.\n\n\nExample\n\n\ne.Use(mw.Gzip())\n\n\n\n\nRecover\n\n\nRecover middleware recovers from panics anywhere in the chain and handles the control\nto the centralized \nHTTPErrorHandler\n.\n\n\nExample\n\n\ne.Use(mw.Recover())\n\n\n\n\nStripTrailingSlash\n\n\nStripTrailingSlash middleware removes the trailing slash from request path.\n\n\nExample\n\n\ne.Use(mw.StripTrailingSlash())\n\n\n\n\nRedirectToSlash\n\n\nRedirectToSlash middleware redirects requests without trailing slash path to trailing\nslash path.\n\n\nOptions\n\n\nRedirectToSlashOptions struct {\n    Code int\n}\n\n\n\n\nExample\n\n\ne.Use(mw.RedirectToSlash())\n\n\n\n\n\n\nStripTrailingSlash and RedirectToSlash middleware should not be used together.\n\n\n\n\nExamples\n\n\nResponse\n\n\nJSON\n\n\ncontext.JSON(code int, v interface{}) error\n\n\n\n\nSends a JSON HTTP response with status code.\n\n\nString\n\n\ncontext.String(code int, s string) error\n\n\n\n\nSends a text/plain HTTP response with status code.\n\n\nHTML\n\n\nfunc (c *Context) HTML(code int, html string) error\n\n\n\n\nSends an HTML HTTP response with status code.\n\n\nStatic files\n\n\nEcho.Static(path, root string)\n serves static files. For example, code below serves\nfiles from directory \npublic/scripts\n for any request path starting with \n/scripts/\n.\n\n\ne.Static(\n/scripts/\n, \npublic/scripts\n)\n\n\n\n\nServing a file\n\n\nEcho.ServeFile(path, file string)\n serves a file. For example, code below serves\nfile \nwelcome.html\n for request path \n/welcome\n.\n\n\ne.ServeFile(\n/welcome\n, \nwelcome.html\n)\n\n\n\n\nServing an index file\n\n\nEcho.Index(file string)\n serves root index page - \nGET /\n. For example, code below\nserves root index page from file \npublic/index.html\n.\n\n\ne.Index(\npublic/index.html\n)\n\n\n\n\nServing favicon\n\n\nEcho.Favicon(file string)\n serves default favicon - \nGET /favicon.ico\n. For example,\ncode below serves favicon from file \npublic/favicon.ico\n.\n\n\ne.Favicon(\npublic/favicon.ico\n)\n\n\n\n\nError Handling\n\n\nEcho advocates centralized HTTP error handling by returning \nerror\n from middleware\nand handlers.\n\n\nIt allows you to\n\n\n\n\nDebug by writing stack trace to the HTTP response.\n\n\nCustomize HTTP responses.\n\n\nRecover from panics inside middleware or handlers.\n\n\n\n\nFor example, when basic auth middleware finds invalid credentials it returns\n\n401 - Unauthorized\n error, aborting the current HTTP request.\n\n\npackage main\n\nimport (\n    \nnet/http\n\n\n    \ngithub.com/labstack/echo\n\n)\n\nfunc main() {\n    e := echo.New()\n    e.Use(func(c *echo.Context) error {\n        // Extract the credentials from HTTP request header and perform a security\n        // check\n\n        // For invalid credentials\n        return echo.NewHTTPError(http.StatusUnauthorized)\n    })\n    e.Get(\n/welcome\n, welcome)\n    e.Run(\n:1323\n)\n}\n\nfunc welcome(c *echo.Context) error {\n    return c.String(http.StatusOK, \nWelcome!\n)\n}\n\n\n\n\nSee how \nHTTPErrorHandler\n handles it.\n\n\nDeployment\n\n\nWIP", 
            "title": "Guide"
        }, 
        {
            "location": "/guide/#guide", 
            "text": "", 
            "title": "Guide"
        }, 
        {
            "location": "/guide/#installation", 
            "text": "Echo has been developed and tested using Go  1.4.x  Install the latest version of Echo via  go get  $ go get github.com/labstack/echo  To upgrade  $ go get -u github.com/labstack/echo  Echo follows  semantic versioning  managed through GitHub releases.\nSpecific version of Echo can be installed using any  package manager .", 
            "title": "Installation"
        }, 
        {
            "location": "/guide/#customization", 
            "text": "HTTP error handler  Echo.SetHTTPErrorHandler(h HTTPErrorHandler)  Registers a custom  Echo.HTTPErrorHandler .  Default handler rules   If error is of type  Echo.HTTPError  it sends HTTP response with status code  HTTPError.Code \nand message  HTTPError.Message .  Else it sends  500 - Internal Server Error .  If debug mode is enabled, it uses  error.Error()  as status message.   Debug  Echo.SetDebug(on bool)  Enables debug mode.", 
            "title": "Customization"
        }, 
        {
            "location": "/guide/#routing", 
            "text": "Echo's router is  fast, optimized  and\nflexible. It's based on  radix tree \ndata structure which makes routing lookup really fast. It leverages sync pool  to reuse memory and achieve\nzero dynamic memory allocation with no GC overhead.  Routes can be registered by specifying HTTP method, path and a handler. For example,\ncode below registers a route for method  GET , path  /hello  and a handler which sends Hello!  HTTP response.  echo.Get( /hello , func(c *echo.Context) error {\n    return c.String(http.StatusOK,  Hello! )\n})  Echo's default handler is  func(*echo.Context) error  where  echo.Context \nprimarily holds HTTP request and response objects. Echo also has a support for other\ntypes of handlers.  Path parameter  Request path parameters can be extracted either by name  Echo.Context.Param(name string) string \nor by index  Echo.Context.P(i int) string . Getting parameter by index gives a\nslightly better performance.  echo.Get( /users/:id , func(c *echo.Context) error {\n    // By name\n    id := c.Param( id )\n\n    // By index\n    id := c.P(0)\n\n    return c.String(http.StatusOK, id)\n})  Match-any  Matches zero or more characters in the path. For example, pattern  /users/*  will\nmatch   /users/  /users/1  /users/1/files/1  /users/anything...   Path matching order   Static  Param  Match any   Example  e.Get( /users/:id , func(c *echo.Context) error {\n    return c.String(http.StatusOK,  /users/:id )\n})\n\ne.Get( /users/new , func(c *echo.Context) error {\n    return c.String(http.StatusOK,  /users/new )\n})\n\ne.Get( /users/1/files/* , func(c *echo.Context) error {\n    return c.String(http.StatusOK,  /users/1/files/* )\n})  Above routes would resolve in order   /users/new  /users/:id  /users/1/files/*   Routes can be written in any order.  Group  Echo.Group(prefix string, m ...Middleware) *Group  Routes with common prefix can be grouped to define a new sub-router with optional\nmiddleware. If middleware is passed to the function, it overrides parent middleware\n- helpful if you want a completely new middleware stack for the group. To add middleware\nlater you can use  Group.Use(m ...Middleware) . Groups can also be nested.  In the code below, we create an admin group which requires basic HTTP authentication\nfor routes  /admin/* .  echo.Group( /admin )\ne.Use(mw.BasicAuth(func(usr, pwd string) bool {\n    if usr ==  joe    pwd ==  secret  {\n        return true\n    }\n    return false\n}))  URI building  Echo.URI  can be used generate URI for any handler with specified path parameters.\nIt's helpful to centralize all your URI patterns which ease in refactoring your\napplication.  echo.URI(h, 1)  will generate  /users/1  for the route registered below  // Handler\nh := func(*echo.Context) error {\n    return c.String(http.StatusOK,  OK )\n}\n\n// Route\ne.Get( /users/:id , h)", 
            "title": "Routing"
        }, 
        {
            "location": "/guide/#middleware", 
            "text": "Middleware is function which is chained in the HTTP request-response cycle. Middleware\nhas access to the request and response objects which it utilizes to perform a specific\naction for example, logging every request. Echo supports variety of  middleware .  Logger  Logs each HTTP request with method, path, status, response time and bytes served.  Example  e.Use(Logger())\n\n// Output: `2015/06/07 18:16:16 GET / 200 13.238\u00b5s 14`  BasicAuth  BasicAuth middleware provides an HTTP basic authentication.   For valid credentials it calls the next handler in the chain.  For invalid Authorization header it sends \"404 - Bad Request\" response.  For invalid credentials, it sends \"401 - Unauthorized\" response.   Example  echo.Group( /admin )\ne.Use(mw.BasicAuth(func(usr, pwd string) bool {\n    if usr ==  joe    pwd ==  secret  {\n        return true\n    }\n    return false\n}))  Gzip  Gzip middleware compresses HTTP response using gzip compression scheme.  Example  e.Use(mw.Gzip())  Recover  Recover middleware recovers from panics anywhere in the chain and handles the control\nto the centralized  HTTPErrorHandler .  Example  e.Use(mw.Recover())  StripTrailingSlash  StripTrailingSlash middleware removes the trailing slash from request path.  Example  e.Use(mw.StripTrailingSlash())  RedirectToSlash  RedirectToSlash middleware redirects requests without trailing slash path to trailing\nslash path.  Options  RedirectToSlashOptions struct {\n    Code int\n}  Example  e.Use(mw.RedirectToSlash())   StripTrailingSlash and RedirectToSlash middleware should not be used together.   Examples", 
            "title": "Middleware"
        }, 
        {
            "location": "/guide/#response", 
            "text": "JSON  context.JSON(code int, v interface{}) error  Sends a JSON HTTP response with status code.  String  context.String(code int, s string) error  Sends a text/plain HTTP response with status code.  HTML  func (c *Context) HTML(code int, html string) error  Sends an HTML HTTP response with status code.  Static files  Echo.Static(path, root string)  serves static files. For example, code below serves\nfiles from directory  public/scripts  for any request path starting with  /scripts/ .  e.Static( /scripts/ ,  public/scripts )  Serving a file  Echo.ServeFile(path, file string)  serves a file. For example, code below serves\nfile  welcome.html  for request path  /welcome .  e.ServeFile( /welcome ,  welcome.html )  Serving an index file  Echo.Index(file string)  serves root index page -  GET / . For example, code below\nserves root index page from file  public/index.html .  e.Index( public/index.html )  Serving favicon  Echo.Favicon(file string)  serves default favicon -  GET /favicon.ico . For example,\ncode below serves favicon from file  public/favicon.ico .  e.Favicon( public/favicon.ico )", 
            "title": "Response"
        }, 
        {
            "location": "/guide/#error-handling", 
            "text": "Echo advocates centralized HTTP error handling by returning  error  from middleware\nand handlers.  It allows you to   Debug by writing stack trace to the HTTP response.  Customize HTTP responses.  Recover from panics inside middleware or handlers.   For example, when basic auth middleware finds invalid credentials it returns 401 - Unauthorized  error, aborting the current HTTP request.  package main\n\nimport (\n     net/http \n\n     github.com/labstack/echo \n)\n\nfunc main() {\n    e := echo.New()\n    e.Use(func(c *echo.Context) error {\n        // Extract the credentials from HTTP request header and perform a security\n        // check\n\n        // For invalid credentials\n        return echo.NewHTTPError(http.StatusUnauthorized)\n    })\n    e.Get( /welcome , welcome)\n    e.Run( :1323 )\n}\n\nfunc welcome(c *echo.Context) error {\n    return c.String(http.StatusOK,  Welcome! )\n}  See how  HTTPErrorHandler  handles it.", 
            "title": "Error Handling"
        }, 
        {
            "location": "/guide/#deployment", 
            "text": "WIP", 
            "title": "Deployment"
        }, 
        {
            "location": "/recipes/file-upload/", 
            "text": "File Upload\n\n\n\n\nMultipart/form-data file upload\n\n\nMultiple form fields and files\n\n\n\n\nUse \nreq.ParseMultipartForm(16 \n 20)\n for manually parsing multipart form. It gives\nus an option to specify the maximum memory used while parsing the request body. \n\n\nServer\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nio\n\n    \nos\n\n\n    \nnet/http\n\n\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n)\n\nfunc upload(c *echo.Context) error {\n    req := c.Request()\n\n    // req.ParseMultipartForm(16 \n 20) // Max memory 16 MiB\n\n    // Read form fields\n    name := c.Form(\nname\n)\n    email := c.Form(\nemail\n)\n\n    // Read files\n    files := req.MultipartForm.File[\nfiles\n]\n    for _, f := range files {\n        // Source file\n        src, err := f.Open()\n        if err != nil {\n            return err\n        }\n        defer src.Close()\n\n        // Destination file\n        dst, err := os.Create(f.Filename)\n        if err != nil {\n            return err\n        }\n        defer dst.Close()\n\n        if _, err = io.Copy(dst, src); err != nil {\n            return err\n        }\n    }\n    return c.String(http.StatusOK, \nThank You! %s \n%s\n, %d files uploaded successfully.\n,\n        name, email, len(files))\n}\n\nfunc main() {\n    e := echo.New()\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static(\n/\n, \npublic\n)\n    e.Post(\n/upload\n, upload)\n\n    e.Run(\n:1323\n)\n}\n\n\n\n\nClient\n\n\nindex.html\n\n\n!doctype html\n\n\nhtml lang=\nen\n\n\nhead\n\n    \nmeta charset=\nutf-8\n\n    \ntitle\nFile Upload\n/title\n\n\n/head\n\n\nbody\n\n    \nh1\nUpload Files\n/h1\n\n    \nform action=\n/upload\n method=\npost\n enctype=\nmultipart/form-data\n\n        Name: \ninput type=\ntext\n name=\nname\nbr\n\n        Email: \ninput type=\nemail\n name=\nemail\nbr\n\n        Files: \ninput type=\nfile\n name=\nfiles\n multiple\nbr\nbr\n\n        \ninput type=\nsubmit\n value=\nSubmit\n\n    \n/form\n\n\n/body\n\n\n/html\n\n\n\n\n\n\nSource Code", 
            "title": "File Upload"
        }, 
        {
            "location": "/recipes/file-upload/#file-upload", 
            "text": "Multipart/form-data file upload  Multiple form fields and files   Use  req.ParseMultipartForm(16   20)  for manually parsing multipart form. It gives\nus an option to specify the maximum memory used while parsing the request body.", 
            "title": "File Upload"
        }, 
        {
            "location": "/recipes/file-upload/#server", 
            "text": "server.go  package main\n\nimport (\n     io \n     os \n\n     net/http \n\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n)\n\nfunc upload(c *echo.Context) error {\n    req := c.Request()\n\n    // req.ParseMultipartForm(16   20) // Max memory 16 MiB\n\n    // Read form fields\n    name := c.Form( name )\n    email := c.Form( email )\n\n    // Read files\n    files := req.MultipartForm.File[ files ]\n    for _, f := range files {\n        // Source file\n        src, err := f.Open()\n        if err != nil {\n            return err\n        }\n        defer src.Close()\n\n        // Destination file\n        dst, err := os.Create(f.Filename)\n        if err != nil {\n            return err\n        }\n        defer dst.Close()\n\n        if _, err = io.Copy(dst, src); err != nil {\n            return err\n        }\n    }\n    return c.String(http.StatusOK,  Thank You! %s  %s , %d files uploaded successfully. ,\n        name, email, len(files))\n}\n\nfunc main() {\n    e := echo.New()\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static( / ,  public )\n    e.Post( /upload , upload)\n\n    e.Run( :1323 )\n}", 
            "title": "Server"
        }, 
        {
            "location": "/recipes/file-upload/#client", 
            "text": "index.html  !doctype html  html lang= en  head \n     meta charset= utf-8 \n     title File Upload /title  /head  body \n     h1 Upload Files /h1 \n     form action= /upload  method= post  enctype= multipart/form-data \n        Name:  input type= text  name= name br \n        Email:  input type= email  name= email br \n        Files:  input type= file  name= files  multiple br br \n         input type= submit  value= Submit \n     /form  /body  /html", 
            "title": "Client"
        }, 
        {
            "location": "/recipes/file-upload/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/streaming-file-upload/", 
            "text": "Streaming File Upload\n\n\n\n\nStreaming multipart/form-data file upload\n\n\nMultiple form fields and files\n\n\n\n\nServer\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nio/ioutil\n\n\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n    \nio\n\n    \nnet/http\n\n    \nos\n\n)\n\nfunc upload(c *echo.Context) error {\n    mr, err := c.Request().MultipartReader()\n    if err != nil {\n        return err\n    }\n\n    // Read form field `name`\n    part, err := mr.NextPart()\n    if err != nil {\n        return err\n    }\n    defer part.Close()\n    b, err := ioutil.ReadAll(part)\n    if err != nil {\n        return err\n    }\n    name := string(b)\n\n    // Read form field `email`\n    part, err = mr.NextPart()\n    if err != nil {\n        return err\n    }\n    defer part.Close()\n    b, err = ioutil.ReadAll(part)\n    if err != nil {\n        return err\n    }\n    email := string(b)\n\n    // Read files\n    i := 0\n    for {\n        part, err := mr.NextPart()\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return err\n        }\n        defer part.Close()\n\n        file, err := os.Create(part.FileName())\n        if err != nil {\n            return err\n        }\n        defer file.Close()\n\n        if _, err := io.Copy(file, part); err != nil {\n            return err\n        }\n        i++\n    }\n    return c.String(http.StatusOK, \nThank You! %s \n%s\n, %d files uploaded successfully.\n,\n        name, email, i)\n}\n\nfunc main() {\n    e := echo.New()\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static(\n/\n, \npublic\n)\n    e.Post(\n/upload\n, upload)\n\n    e.Run(\n:1323\n)\n}\n\n\n\n\nClient\n\n\nindex.html\n\n\n!doctype html\n\n\nhtml lang=\nen\n\n\nhead\n\n    \nmeta charset=\nutf-8\n\n    \ntitle\nFile Upload\n/title\n\n\n/head\n\n\nbody\n\n    \nh1\nUpload Files\n/h1\n\n    \nform action=\n/upload\n method=\npost\n enctype=\nmultipart/form-data\n\n        Name: \ninput type=\ntext\n name=\nname\nbr\n\n        Email: \ninput type=\nemail\n name=\nemail\nbr\n\n        Files: \ninput type=\nfile\n name=\nfiles\n multiple\nbr\nbr\n\n        \ninput type=\nsubmit\n value=\nSubmit\n\n    \n/form\n\n\n/body\n\n\n/html\n\n\n\n\n\n\nSource Code", 
            "title": "Streaming File Upload"
        }, 
        {
            "location": "/recipes/streaming-file-upload/#streaming-file-upload", 
            "text": "Streaming multipart/form-data file upload  Multiple form fields and files", 
            "title": "Streaming File Upload"
        }, 
        {
            "location": "/recipes/streaming-file-upload/#server", 
            "text": "server.go  package main\n\nimport (\n     io/ioutil \n\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n     io \n     net/http \n     os \n)\n\nfunc upload(c *echo.Context) error {\n    mr, err := c.Request().MultipartReader()\n    if err != nil {\n        return err\n    }\n\n    // Read form field `name`\n    part, err := mr.NextPart()\n    if err != nil {\n        return err\n    }\n    defer part.Close()\n    b, err := ioutil.ReadAll(part)\n    if err != nil {\n        return err\n    }\n    name := string(b)\n\n    // Read form field `email`\n    part, err = mr.NextPart()\n    if err != nil {\n        return err\n    }\n    defer part.Close()\n    b, err = ioutil.ReadAll(part)\n    if err != nil {\n        return err\n    }\n    email := string(b)\n\n    // Read files\n    i := 0\n    for {\n        part, err := mr.NextPart()\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return err\n        }\n        defer part.Close()\n\n        file, err := os.Create(part.FileName())\n        if err != nil {\n            return err\n        }\n        defer file.Close()\n\n        if _, err := io.Copy(file, part); err != nil {\n            return err\n        }\n        i++\n    }\n    return c.String(http.StatusOK,  Thank You! %s  %s , %d files uploaded successfully. ,\n        name, email, i)\n}\n\nfunc main() {\n    e := echo.New()\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static( / ,  public )\n    e.Post( /upload , upload)\n\n    e.Run( :1323 )\n}", 
            "title": "Server"
        }, 
        {
            "location": "/recipes/streaming-file-upload/#client", 
            "text": "index.html  !doctype html  html lang= en  head \n     meta charset= utf-8 \n     title File Upload /title  /head  body \n     h1 Upload Files /h1 \n     form action= /upload  method= post  enctype= multipart/form-data \n        Name:  input type= text  name= name br \n        Email:  input type= email  name= email br \n        Files:  input type= file  name= files  multiple br br \n         input type= submit  value= Submit \n     /form  /body  /html", 
            "title": "Client"
        }, 
        {
            "location": "/recipes/streaming-file-upload/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/streaming-response/", 
            "text": "Streaming Response\n\n\n\n\nSend data as it is produced\n\n\nStreaming JSON response with chunked transfer encoding\n\n\n\n\nServer\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nnet/http\n\n    \ntime\n\n\n    \nencoding/json\n\n\n    \ngithub.com/labstack/echo\n\n)\n\ntype (\n    Geolocation struct {\n        Altitude  float64\n        Latitude  float64\n        Longitude float64\n    }\n)\n\nvar (\n    locations = []Geolocation{\n        {-97, 37.819929, -122.478255},\n        {1899, 39.096849, -120.032351},\n        {2619, 37.865101, -119.538329},\n        {42, 33.812092, -117.918974},\n        {15, 37.77493, -122.419416},\n    }\n)\n\nfunc main() {\n    e := echo.New()\n    e.Get(\n/\n, func(c *echo.Context) error {\n        c.Response().Header().Set(echo.ContentType, echo.ApplicationJSON)\n        c.Response().WriteHeader(http.StatusOK)\n        for _, l := range locations {\n            if err := json.NewEncoder(c.Response()).Encode(l); err != nil {\n                return err\n            }\n            c.Response().Flush()\n            time.Sleep(1 * time.Second)\n        }\n        return nil\n    })\n    e.Run(\n:1323\n)\n}\n\n\n\n\nClient\n\n\n$ curl localhost:1323\n\n\n\n\nOutput\n\n\n{\nAltitude\n:-97,\nLatitude\n:37.819929,\nLongitude\n:-122.478255}\n{\nAltitude\n:1899,\nLatitude\n:39.096849,\nLongitude\n:-120.032351}\n{\nAltitude\n:2619,\nLatitude\n:37.865101,\nLongitude\n:-119.538329}\n{\nAltitude\n:42,\nLatitude\n:33.812092,\nLongitude\n:-117.918974}\n{\nAltitude\n:15,\nLatitude\n:37.77493,\nLongitude\n:-122.419416}\n\n\n\n\nSource Code", 
            "title": "Streaming Response"
        }, 
        {
            "location": "/recipes/streaming-response/#streaming-response", 
            "text": "Send data as it is produced  Streaming JSON response with chunked transfer encoding", 
            "title": "Streaming Response"
        }, 
        {
            "location": "/recipes/streaming-response/#server", 
            "text": "server.go  package main\n\nimport (\n     net/http \n     time \n\n     encoding/json \n\n     github.com/labstack/echo \n)\n\ntype (\n    Geolocation struct {\n        Altitude  float64\n        Latitude  float64\n        Longitude float64\n    }\n)\n\nvar (\n    locations = []Geolocation{\n        {-97, 37.819929, -122.478255},\n        {1899, 39.096849, -120.032351},\n        {2619, 37.865101, -119.538329},\n        {42, 33.812092, -117.918974},\n        {15, 37.77493, -122.419416},\n    }\n)\n\nfunc main() {\n    e := echo.New()\n    e.Get( / , func(c *echo.Context) error {\n        c.Response().Header().Set(echo.ContentType, echo.ApplicationJSON)\n        c.Response().WriteHeader(http.StatusOK)\n        for _, l := range locations {\n            if err := json.NewEncoder(c.Response()).Encode(l); err != nil {\n                return err\n            }\n            c.Response().Flush()\n            time.Sleep(1 * time.Second)\n        }\n        return nil\n    })\n    e.Run( :1323 )\n}", 
            "title": "Server"
        }, 
        {
            "location": "/recipes/streaming-response/#client", 
            "text": "$ curl localhost:1323", 
            "title": "Client"
        }, 
        {
            "location": "/recipes/streaming-response/#output", 
            "text": "{ Altitude :-97, Latitude :37.819929, Longitude :-122.478255}\n{ Altitude :1899, Latitude :39.096849, Longitude :-120.032351}\n{ Altitude :2619, Latitude :37.865101, Longitude :-119.538329}\n{ Altitude :42, Latitude :33.812092, Longitude :-117.918974}\n{ Altitude :15, Latitude :37.77493, Longitude :-122.419416}", 
            "title": "Output"
        }, 
        {
            "location": "/recipes/streaming-response/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/websocket/", 
            "text": "WebSocket\n\n\nServer\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n    \ngolang.org/x/net/websocket\n\n)\n\nfunc main() {\n    e := echo.New()\n\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static(\n/\n, \npublic\n)\n    e.WebSocket(\n/ws\n, func(c *echo.Context) (err error) {\n        ws := c.Socket()\n        msg := \n\n\n        for {\n            if err = websocket.Message.Send(ws, \nHello, Client!\n); err != nil {\n                return\n            }\n            if err = websocket.Message.Receive(ws, \nmsg); err != nil {\n                return\n            }\n            println(msg)\n        }\n        return\n    })\n\n    e.Run(\n:1323\n)\n}\n\n\n\n\nClient\n\n\nindex.html\n\n\n!doctype html\n\n\nhtml lang=\nen\n\n\nhead\n\n    \nmeta charset=\nutf-8\n\n    \ntitle\nWebSocket\n/title\n\n\n/head\n\n\nbody\n\n    \np id=\noutput\n/p\n\n\n    \nscript\n\n        var loc = window.location;\n        var uri = 'ws:';\n\n        if (loc.protocol === 'https:') {\n            uri = 'wss:';\n        }\n        uri += '//' + loc.host;\n        uri += loc.pathname + 'ws';\n\n        ws = new WebSocket(uri)\n\n        ws.onopen = function() {\n            console.log('Connected')\n        }\n\n        ws.onmessage = function(evt) {\n            var out = document.getElementById('output');\n            out.innerHTML += evt.data + '\nbr\n';\n        }\n\n        setInterval(function() {\n            ws.send('Hello, Server!');\n        }, 1000);\n    \n/script\n\n\n/body\n\n\n/html\n\n\n\n\n\nOutput\n\n\nClient\n\n\nHello, Client!\nHello, Client!\nHello, Client!\nHello, Client!\nHello, Client!\n\n\n\n\nServer\n\n\nHello, Server!\nHello, Server!\nHello, Server!\nHello, Server!\nHello, Server!\n\n\n\n\nSource Code", 
            "title": "WebSocket"
        }, 
        {
            "location": "/recipes/websocket/#websocket", 
            "text": "", 
            "title": "WebSocket"
        }, 
        {
            "location": "/recipes/websocket/#server", 
            "text": "server.go  package main\n\nimport (\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n     golang.org/x/net/websocket \n)\n\nfunc main() {\n    e := echo.New()\n\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static( / ,  public )\n    e.WebSocket( /ws , func(c *echo.Context) (err error) {\n        ws := c.Socket()\n        msg :=  \n\n        for {\n            if err = websocket.Message.Send(ws,  Hello, Client! ); err != nil {\n                return\n            }\n            if err = websocket.Message.Receive(ws,  msg); err != nil {\n                return\n            }\n            println(msg)\n        }\n        return\n    })\n\n    e.Run( :1323 )\n}", 
            "title": "Server"
        }, 
        {
            "location": "/recipes/websocket/#client", 
            "text": "index.html  !doctype html  html lang= en  head \n     meta charset= utf-8 \n     title WebSocket /title  /head  body \n     p id= output /p \n\n     script \n        var loc = window.location;\n        var uri = 'ws:';\n\n        if (loc.protocol === 'https:') {\n            uri = 'wss:';\n        }\n        uri += '//' + loc.host;\n        uri += loc.pathname + 'ws';\n\n        ws = new WebSocket(uri)\n\n        ws.onopen = function() {\n            console.log('Connected')\n        }\n\n        ws.onmessage = function(evt) {\n            var out = document.getElementById('output');\n            out.innerHTML += evt.data + ' br ';\n        }\n\n        setInterval(function() {\n            ws.send('Hello, Server!');\n        }, 1000);\n     /script  /body  /html", 
            "title": "Client"
        }, 
        {
            "location": "/recipes/websocket/#output", 
            "text": "Client  Hello, Client!\nHello, Client!\nHello, Client!\nHello, Client!\nHello, Client!  Server  Hello, Server!\nHello, Server!\nHello, Server!\nHello, Server!\nHello, Server!", 
            "title": "Output"
        }, 
        {
            "location": "/recipes/websocket/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/subdomains/", 
            "text": "Subdomains\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nnet/http\n\n\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n)\n\ntype Hosts map[string]http.Handler\n\nfunc (h Hosts) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if handler := h[r.Host]; handler != nil {\n        handler.ServeHTTP(w, r)\n    } else {\n        http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n    }\n}\n\nfunc main() {\n    // Host map\n    hosts := make(Hosts)\n\n    //-----\n    // API\n    //-----\n\n    api := echo.New()\n    api.Use(mw.Logger())\n    api.Use(mw.Recover())\n\n    hosts[\napi.localhost:1323\n] = api\n\n    api.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nAPI\n)\n    })\n\n    //------\n    // Blog\n    //------\n\n    blog := echo.New()\n    blog.Use(mw.Logger())\n    blog.Use(mw.Recover())\n\n    hosts[\nblog.localhost:1323\n] = blog\n\n    blog.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nBlog\n)\n    })\n\n    //---------\n    // Website\n    //---------\n\n    site := echo.New()\n    site.Use(mw.Logger())\n    site.Use(mw.Recover())\n\n    hosts[\nlocalhost:1323\n] = site\n\n    site.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nWelcome!\n)\n    })\n\n    http.ListenAndServe(\n:1323\n, hosts)\n}\n\n\n\n\nSource Code", 
            "title": "Subdomains"
        }, 
        {
            "location": "/recipes/subdomains/#subdomains", 
            "text": "server.go  package main\n\nimport (\n     net/http \n\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n)\n\ntype Hosts map[string]http.Handler\n\nfunc (h Hosts) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if handler := h[r.Host]; handler != nil {\n        handler.ServeHTTP(w, r)\n    } else {\n        http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n    }\n}\n\nfunc main() {\n    // Host map\n    hosts := make(Hosts)\n\n    //-----\n    // API\n    //-----\n\n    api := echo.New()\n    api.Use(mw.Logger())\n    api.Use(mw.Recover())\n\n    hosts[ api.localhost:1323 ] = api\n\n    api.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  API )\n    })\n\n    //------\n    // Blog\n    //------\n\n    blog := echo.New()\n    blog.Use(mw.Logger())\n    blog.Use(mw.Recover())\n\n    hosts[ blog.localhost:1323 ] = blog\n\n    blog.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  Blog )\n    })\n\n    //---------\n    // Website\n    //---------\n\n    site := echo.New()\n    site.Use(mw.Logger())\n    site.Use(mw.Recover())\n\n    hosts[ localhost:1323 ] = site\n\n    site.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  Welcome! )\n    })\n\n    http.ListenAndServe( :1323 , hosts)\n}", 
            "title": "Subdomains"
        }, 
        {
            "location": "/recipes/subdomains/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/jwt-auth/", 
            "text": "JWT Authentication\n\n\nMost applications dealing with client authentication will require a more secure mechanism than that provided by \nbasic authentication\n. \nJSON Web Tokens\n are one such mechanism - JWTs are a compact means of transfering cryptographically signed claims between the client and server. \n\n\nThis recipe demonstrates the use of a simple JWT authentication Echo middleware using Dave Grijalva's \njwt-go\n. This middleware expects the token to be present in an Authorization HTTP header using the method \"Bearer\", although JWTs are also frequently sent using cookies, the request URL, or even the request body. We will use the HS236 signing method, note that several other algorithms are avaible.\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nfmt\n\n    \nnet/http\n\n\n    \ngithub.com/dgrijalva/jwt-go\n\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n)\n\nconst (\n    Bearer     = \nBearer\n\n    SigningKey = \nsomethingsupersecret\n\n)\n\n// A JSON Web Token middleware\nfunc JWTAuth(key string) echo.HandlerFunc {\n    return func(c *echo.Context) error {\n\n        // Skip WebSocket\n        if (c.Request().Header.Get(echo.Upgrade)) == echo.WebSocket {\n            return nil\n        }\n\n        auth := c.Request().Header.Get(\nAuthorization\n)\n        l := len(Bearer)\n        he := echo.NewHTTPError(http.StatusUnauthorized)\n\n        if len(auth) \n l+1 \n auth[:l] == Bearer {\n            t, err := jwt.Parse(auth[l+1:], func(token *jwt.Token) (interface{}, error) {\n\n                // Always check the signing method\n                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n                    return nil, fmt.Errorf(\nUnexpected signing method: %v\n, token.Header[\nalg\n])\n                }\n\n                // Return the key for validation\n                return []byte(key), nil\n            })\n            if err == nil \n t.Valid {\n                // Store token claims in echo.Context\n                c.Set(\nclaims\n, t.Claims)\n                return nil\n            }\n        }\n        return he\n    }\n}\n\nfunc accessible(c *echo.Context) error {\n    return c.String(http.StatusOK, \nNo auth required for this route.\\n\n)\n}\n\nfunc restricted(c *echo.Context) error {\n    return c.String(http.StatusOK, \nAccess granted with JWT.\\n\n)\n}\n\nfunc main() {\n\n    // Echo instance\n    e := echo.New()\n\n    // Logger\n    e.Use(mw.Logger())\n\n    // Unauthenticated route\n    e.Get(\n/\n, accessible)\n\n    // Restricted group\n    r := e.Group(\n/restricted\n)\n    r.Use(JWTAuth(SigningKey))\n    r.Get(\n, restricted)\n\n    // Start server\n    e.Run(\n:1323\n)\n}\n\n\n\n\nSource Code\n\n\nRun \nserver.go\n and making a request to the root path \n/\n returns a 200 OK response, as this route does not use our JWT authentication middleware. Sending requests to \n/restricted\n (our authenticated route) with either no Authorization header or invalid Authorization headers / tokens will return 401 Unauthorized.\n\n\n// Unauthenticated route\n$ curl localhost:1323/  =\n No auth required for this route.\n\n// No Authentication header\n$ curl localhost:1323/restricted  =\n Unauthorized\n\n// Invalid Authentication method\n$  curl localhost:1323/restricted -H \nAuthorization: Invalid \n =\n Unauthorized\n\n// Invalid token\n$  curl localhost:1323/restricted -H \nAuthorization: Bearer InvalidToken\n =\n Unauthorized\n\n\n\n\nRunning \ntoken.go\n (source) will print JWT that is valid against this middleware to stdout. You can use this token to test succesful authentication on the \n/restricted\n path.\n\n\npackage main\n\nimport (\n    \nfmt\n\n    \ntime\n\n\n    \ngithub.com/dgrijalva/jwt-go\n\n)\n\nconst SigningKey = \nsomethingsupersecret\n\n\nfunc main() {\n\n    // New web token.\n    token := jwt.New(jwt.SigningMethodHS256)\n\n    // Set a header and a claim\n    token.Header[\ntyp\n] = \nJWT\n\n    token.Claims[\nexp\n] = time.Now().Add(time.Hour * 96).Unix()\n\n    // Generate encoded token\n    t, _ := token.SignedString([]byte(SigningKey))\n    fmt.Println(t)\n}\n\n\n\n\nSource Code\n\n\n// Valid token\n$  curl localhost:1323/restricted -H \nAuthorization: Bearer \ntoken\n =\n Access granted with JWT.", 
            "title": "JWT Authentication"
        }, 
        {
            "location": "/recipes/jwt-auth/#jwt-authentication", 
            "text": "Most applications dealing with client authentication will require a more secure mechanism than that provided by  basic authentication .  JSON Web Tokens  are one such mechanism - JWTs are a compact means of transfering cryptographically signed claims between the client and server.   This recipe demonstrates the use of a simple JWT authentication Echo middleware using Dave Grijalva's  jwt-go . This middleware expects the token to be present in an Authorization HTTP header using the method \"Bearer\", although JWTs are also frequently sent using cookies, the request URL, or even the request body. We will use the HS236 signing method, note that several other algorithms are avaible.  server.go  package main\n\nimport (\n     fmt \n     net/http \n\n     github.com/dgrijalva/jwt-go \n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n)\n\nconst (\n    Bearer     =  Bearer \n    SigningKey =  somethingsupersecret \n)\n\n// A JSON Web Token middleware\nfunc JWTAuth(key string) echo.HandlerFunc {\n    return func(c *echo.Context) error {\n\n        // Skip WebSocket\n        if (c.Request().Header.Get(echo.Upgrade)) == echo.WebSocket {\n            return nil\n        }\n\n        auth := c.Request().Header.Get( Authorization )\n        l := len(Bearer)\n        he := echo.NewHTTPError(http.StatusUnauthorized)\n\n        if len(auth)   l+1   auth[:l] == Bearer {\n            t, err := jwt.Parse(auth[l+1:], func(token *jwt.Token) (interface{}, error) {\n\n                // Always check the signing method\n                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n                    return nil, fmt.Errorf( Unexpected signing method: %v , token.Header[ alg ])\n                }\n\n                // Return the key for validation\n                return []byte(key), nil\n            })\n            if err == nil   t.Valid {\n                // Store token claims in echo.Context\n                c.Set( claims , t.Claims)\n                return nil\n            }\n        }\n        return he\n    }\n}\n\nfunc accessible(c *echo.Context) error {\n    return c.String(http.StatusOK,  No auth required for this route.\\n )\n}\n\nfunc restricted(c *echo.Context) error {\n    return c.String(http.StatusOK,  Access granted with JWT.\\n )\n}\n\nfunc main() {\n\n    // Echo instance\n    e := echo.New()\n\n    // Logger\n    e.Use(mw.Logger())\n\n    // Unauthenticated route\n    e.Get( / , accessible)\n\n    // Restricted group\n    r := e.Group( /restricted )\n    r.Use(JWTAuth(SigningKey))\n    r.Get( , restricted)\n\n    // Start server\n    e.Run( :1323 )\n}  Source Code  Run  server.go  and making a request to the root path  /  returns a 200 OK response, as this route does not use our JWT authentication middleware. Sending requests to  /restricted  (our authenticated route) with either no Authorization header or invalid Authorization headers / tokens will return 401 Unauthorized.  // Unauthenticated route\n$ curl localhost:1323/  =  No auth required for this route.\n\n// No Authentication header\n$ curl localhost:1323/restricted  =  Unauthorized\n\n// Invalid Authentication method\n$  curl localhost:1323/restricted -H  Authorization: Invalid   =  Unauthorized\n\n// Invalid token\n$  curl localhost:1323/restricted -H  Authorization: Bearer InvalidToken  =  Unauthorized  Running  token.go  (source) will print JWT that is valid against this middleware to stdout. You can use this token to test succesful authentication on the  /restricted  path.  package main\n\nimport (\n     fmt \n     time \n\n     github.com/dgrijalva/jwt-go \n)\n\nconst SigningKey =  somethingsupersecret \n\nfunc main() {\n\n    // New web token.\n    token := jwt.New(jwt.SigningMethodHS256)\n\n    // Set a header and a claim\n    token.Header[ typ ] =  JWT \n    token.Claims[ exp ] = time.Now().Add(time.Hour * 96).Unix()\n\n    // Generate encoded token\n    t, _ := token.SignedString([]byte(SigningKey))\n    fmt.Println(t)\n}  Source Code  // Valid token\n$  curl localhost:1323/restricted -H  Authorization: Bearer  token  =  Access granted with JWT.", 
            "title": "JWT Authentication"
        }, 
        {
            "location": "/recipes/graceful-shutdown/", 
            "text": "Graceful Shutdown\n\n\nWith \ngraceful\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nnet/http\n\n    \ntime\n\n\n    \ngithub.com/labstack/echo\n\n    \ngithub.com/tylerb/graceful\n\n)\n\nfunc main() {\n    // Setup\n    e := echo.New()\n    e.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nSue sews rose on slow jor crows nose\n)\n    })\n\n    graceful.ListenAndServe(e.Server(\n:1323\n), 5*time.Second)\n}\n\n\n\n\nWith \ngrace\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nnet/http\n\n\n    \ngithub.com/facebookgo/grace/gracehttp\n\n    \ngithub.com/labstack/echo\n\n)\n\nfunc main() {\n    // Setup\n    e := echo.New()\n    e.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nSix sick bricks tick\n)\n    })\n\n    gracehttp.Serve(e.Server(\n:1323\n))\n}\n\n\n\n\nSource Code\n\n\ngraceful\n\n\ngrace", 
            "title": "Graceful Shutdown"
        }, 
        {
            "location": "/recipes/graceful-shutdown/#graceful-shutdown", 
            "text": "With  graceful  server.go  package main\n\nimport (\n     net/http \n     time \n\n     github.com/labstack/echo \n     github.com/tylerb/graceful \n)\n\nfunc main() {\n    // Setup\n    e := echo.New()\n    e.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  Sue sews rose on slow jor crows nose )\n    })\n\n    graceful.ListenAndServe(e.Server( :1323 ), 5*time.Second)\n}  With  grace  server.go  package main\n\nimport (\n     net/http \n\n     github.com/facebookgo/grace/gracehttp \n     github.com/labstack/echo \n)\n\nfunc main() {\n    // Setup\n    e := echo.New()\n    e.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  Six sick bricks tick )\n    })\n\n    gracehttp.Serve(e.Server( :1323 ))\n}", 
            "title": "Graceful Shutdown"
        }, 
        {
            "location": "/recipes/graceful-shutdown/#source-code", 
            "text": "graceful  grace", 
            "title": "Source Code"
        }
    ]
}