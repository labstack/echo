{
    "docs": [
        {
            "location": "/", 
            "text": "Echo\n\n\nA fast and unfancy micro web framework for Golang.\n\n\n\n\nFeatures\n\n\n\n\nFast HTTP router which smartly prioritize routes.\n\n\nExtensible middleware, supports:\n\n\necho.MiddlewareFunc\n\n\nfunc(echo.HandlerFunc) echo.HandlerFunc\n\n\necho.HandlerFunc\n\n\nfunc(*echo.Context) error\n\n\nfunc(http.Handler) http.Handler\n\n\nhttp.Handler\n\n\nhttp.HandlerFunc\n\n\nfunc(http.ResponseWriter, *http.Request)\n\n\n\n\n\n\nExtensible handler, supports:\n\n\necho.HandlerFunc\n\n\nfunc(*echo.Context) error\n\n\nhttp.Handler\n\n\nhttp.HandlerFunc\n\n\nfunc(http.ResponseWriter, *http.Request)\n\n\n\n\n\n\nSub-router/Groups\n\n\nHandy encoding/decoding functions.\n\n\nBuild-in support for:\n\n\nStatic files\n\n\nWebSocket\n\n\n\n\n\n\nAPI to serve index and favicon.\n\n\nCentralized HTTP error handling.\n\n\nCustomizable request binding function.\n\n\nCustomizable response rendering function, allowing you to use any HTML template engine.\n\n\n\n\nPerformance\n\n\n\n\n\nGetting Started\n\n\nInstallation\n\n\n$ go get github.com/labstack/echo\n\n\n\n\nHello, World!\n\n\nCreate \nserver.go\n with the following content\n\n\npackage main\n\nimport (\n    \nnet/http\n\n\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n)\n\n// Handler\nfunc hello(c *echo.Context) error {\n    return c.String(http.StatusOK, \nHello, World!\\n\n)\n}\n\nfunc main() {\n    // Echo instance\n    e := echo.New()\n\n    // Middleware\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    // Routes\n    e.Get(\n/\n, hello)\n\n    // Start server\n    e.Run(\n:1323\n)\n}\n\n\n\n\necho.New()\n returns a new instance of Echo.\n\n\ne.Use(mw.Logger())\n adds logging middleware to the chain. It logs every HTTP request\nmade to the server, producing output\n\n\n2015/06/07 18:16:16 GET / 200 13.238\u00b5s 14\n\n\n\n\ne.Get(\"/\", hello)\n Registers hello handler for HTTP method \nGET\n and path \n/\n, so\nwhenever server receives an HTTP request at \n/\n, hello function is called.\n\n\nIn hello handler \nc.String(http.StatusOK, \"Hello, World!\\n\")\n sends a text/plain\nHTTP response to the client with 200 status code.\n\n\ne.Run(\":1323\")\n Starts HTTP server at network address \n:1323\n.\n\n\nNow start the server using command\n\n\n$ go run server.go\n\n\n\n\nBrowse to \nhttp://localhost:1323\n and you should see\nHello, World! on the page.\n\n\nNext?\n\n\n\n\nBrowse \nrecipes\n\n\nHead over to \nGuide\n\n\n\n\nContribute\n\n\nUse issues for everything\n\n\n\n\nReport issues\n\n\nDiscuss before sending pull request\n\n\nSuggest new features\n\n\nImprove/fix documentation\n\n\n\n\nCredits\n\n\n\n\nVishal Rana\n - Author\n\n\nNitin Rana\n - Consultant\n\n\nContributors\n\n\n\n\nLicense\n\n\nMIT", 
            "title": "Home"
        }, 
        {
            "location": "/#echo", 
            "text": "A fast and unfancy micro web framework for Golang.", 
            "title": "Echo"
        }, 
        {
            "location": "/#features", 
            "text": "Fast HTTP router which smartly prioritize routes.  Extensible middleware, supports:  echo.MiddlewareFunc  func(echo.HandlerFunc) echo.HandlerFunc  echo.HandlerFunc  func(*echo.Context) error  func(http.Handler) http.Handler  http.Handler  http.HandlerFunc  func(http.ResponseWriter, *http.Request)    Extensible handler, supports:  echo.HandlerFunc  func(*echo.Context) error  http.Handler  http.HandlerFunc  func(http.ResponseWriter, *http.Request)    Sub-router/Groups  Handy encoding/decoding functions.  Build-in support for:  Static files  WebSocket    API to serve index and favicon.  Centralized HTTP error handling.  Customizable request binding function.  Customizable response rendering function, allowing you to use any HTML template engine.", 
            "title": "Features"
        }, 
        {
            "location": "/#performance", 
            "text": "", 
            "title": "Performance"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Installation  $ go get github.com/labstack/echo  Hello, World!  Create  server.go  with the following content  package main\n\nimport (\n     net/http \n\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n)\n\n// Handler\nfunc hello(c *echo.Context) error {\n    return c.String(http.StatusOK,  Hello, World!\\n )\n}\n\nfunc main() {\n    // Echo instance\n    e := echo.New()\n\n    // Middleware\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    // Routes\n    e.Get( / , hello)\n\n    // Start server\n    e.Run( :1323 )\n}  echo.New()  returns a new instance of Echo.  e.Use(mw.Logger())  adds logging middleware to the chain. It logs every HTTP request\nmade to the server, producing output  2015/06/07 18:16:16 GET / 200 13.238\u00b5s 14  e.Get(\"/\", hello)  Registers hello handler for HTTP method  GET  and path  / , so\nwhenever server receives an HTTP request at  / , hello function is called.  In hello handler  c.String(http.StatusOK, \"Hello, World!\\n\")  sends a text/plain\nHTTP response to the client with 200 status code.  e.Run(\":1323\")  Starts HTTP server at network address  :1323 .  Now start the server using command  $ go run server.go  Browse to  http://localhost:1323  and you should see\nHello, World! on the page.  Next?   Browse  recipes  Head over to  Guide", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#contribute", 
            "text": "Use issues for everything   Report issues  Discuss before sending pull request  Suggest new features  Improve/fix documentation", 
            "title": "Contribute"
        }, 
        {
            "location": "/#credits", 
            "text": "Vishal Rana  - Author  Nitin Rana  - Consultant  Contributors", 
            "title": "Credits"
        }, 
        {
            "location": "/#license", 
            "text": "MIT", 
            "title": "License"
        }, 
        {
            "location": "/guide/", 
            "text": "Guide\n\n\n\n\n\n\n\nInstallation\n\n\nEcho has been developed and tested using Go \n1.4.x\n\n\nInstall the latest version of Echo via \ngo get\n\n\n$ go get github.com/labstack/echo\n\n\n\n\nTo upgrade\n\n\n$ go get -u github.com/labstack/echo\n\n\n\n\nEcho follows \nsemantic versioning\n managed through GitHub releases.\nSpecific version of Echo can be installed using any \npackage manager\n.\n\n\nCustomization\n\n\nHTTP error handler\n\n\nEcho.SetHTTPErrorHandler(h HTTPErrorHandler)\n\n\nRegisters a custom \nEcho.HTTPErrorHandler\n.\n\n\nDefault handler rules\n\n\n\n\nIf error is of type \nEcho.HTTPError\n it sends HTTP response with status code \nHTTPError.Code\n\nand message \nHTTPError.Message\n.\n\n\nElse it sends \n500 - Internal Server Error\n.\n\n\nIf debug mode is enabled, it uses \nerror.Error()\n as status message.\n\n\n\n\nDebug\n\n\nEcho.SetDebug(on bool)\n\n\nEnables debug mode.\n\n\nRouting\n\n\nEcho's router is \nfast, optimized\n and\nflexible. It's based on \nradix tree\n\ndata structure which makes routing lookup really fast. It leverages\n\nsync pool\n to reuse memory and achieve\nzero dynamic memory allocation with no GC overhead.\n\n\nRoutes can be registered by specifying HTTP method, path and a handler. For example,\ncode below registers a route for method \nGET\n, path \n/hello\n and a handler which sends\n\nHello!\n HTTP response.\n\n\necho.Get(\n/hello\n, func(c *echo.Context) error {\n    return c.String(http.StatusOK, \nHello!\n)\n})\n\n\n\n\nEcho's default handler is \nfunc(*echo.Context) error\n where \necho.Context\n\nprimarily holds HTTP request and response objects. Echo also has a support for other\ntypes of handlers.\n\n\nPath parameter\n\n\nRequest path parameters can be extracted either by name \nEcho.Context.Param(name string) string\n\nor by index \nEcho.Context.P(i int) string\n. Getting parameter by index gives a\nslightly better performance.\n\n\necho.Get(\n/users/:id\n, func(c *echo.Context) error {\n    // By name\n    id := c.Param(\nid\n)\n\n    // By index\n    id := c.P(0)\n\n    return c.String(http.StatusOK, id)\n})\n\n\n\n\nMatch-any\n\n\nMatches zero or more characters in the path. For example, pattern \n/users/*\n will\nmatch\n\n\n\n\n/users/\n\n\n/users/1\n\n\n/users/1/files/1\n\n\n/users/anything...\n\n\n\n\nPath matching order\n\n\n\n\nStatic\n\n\nParam\n\n\nMatch any\n\n\n\n\nExample\n\n\ne.Get(\n/users/:id\n, func(c *echo.Context) error {\n    return c.String(http.StatusOK, \n/users/:id\n)\n})\n\ne.Get(\n/users/new\n, func(c *echo.Context) error {\n    return c.String(http.StatusOK, \n/users/new\n)\n})\n\ne.Get(\n/users/1/files/*\n, func(c *echo.Context) error {\n    return c.String(http.StatusOK, \n/users/1/files/*\n)\n})\n\n\n\n\nAbove routes would resolve in order\n\n\n\n\n/users/new\n\n\n/users/:id\n\n\n/users/1/files/*\n\n\n\n\nRoutes can be written in any order.\n\n\nGroup\n\n\nEcho.Group(prefix string, m ...Middleware) *Group\n\n\nRoutes with common prefix can be grouped to define a new sub-router with optional\nmiddleware. If middleware is passed to the function, it overrides parent middleware\n- helpful if you want a completely new middleware stack for the group. To add middleware\nlater you can use \nGroup.Use(m ...Middleware)\n. Groups can also be nested.\n\n\nIn the code below, we create an admin group which requires basic HTTP authentication\nfor routes \n/admin/*\n.\n\n\necho.Group(\n/admin\n)\ne.Use(mw.BasicAuth(func(usr, pwd string) bool {\n    if usr == \njoe\n \n pwd == \nsecret\n {\n        return true\n    }\n    return false\n}))\n\n\n\n\nURI building\n\n\nEcho.URI\n can be used generate URI for any handler with specified path parameters.\nIt's helpful to centralize all your URI patterns which ease in refactoring your\napplication.\n\n\necho.URI(h, 1)\n will generate \n/users/1\n for the route registered below\n\n\n// Handler\nh := func(*echo.Context) error {\n    return c.String(http.StatusOK, \nOK\n)\n}\n\n// Route\ne.Get(\n/users/:id\n, h)\n\n\n\n\nMiddleware\n\n\nMiddleware is function which is chained in the HTTP request-response cycle. Middleware\nhas access to the request and response objects which it utilizes to perform a specific\naction for example, logging every request. Echo supports variety of \nmiddleware\n.\n\n\nLogger\n\n\nLogs each HTTP request with method, path, status, response time and bytes served.\n\n\nExample\n\n\ne.Use(Logger())\n\n// Output: `2015/06/07 18:16:16 GET / 200 13.238\u00b5s 14`\n\n\n\n\nBasicAuth\n\n\nBasicAuth middleware provides an HTTP basic authentication.\n\n\n\n\nFor valid credentials it calls the next handler in the chain.\n\n\nFor invalid Authorization header it sends \"404 - Bad Request\" response.\n\n\nFor invalid credentials, it sends \"401 - Unauthorized\" response.\n\n\n\n\nExample\n\n\necho.Group(\n/admin\n)\ne.Use(mw.BasicAuth(func(usr, pwd string) bool {\n    if usr == \njoe\n \n pwd == \nsecret\n {\n        return true\n    }\n    return false\n}))\n\n\n\n\nGzip\n\n\nGzip middleware compresses HTTP response using gzip compression scheme.\n\n\nExample\n\n\ne.Use(mw.Gzip())\n\n\n\n\nRecover\n\n\nRecover middleware recovers from panics anywhere in the chain and handles the control\nto the centralized \nHTTPErrorHandler\n.\n\n\nExample\n\n\ne.Use(mw.Recover())\n\n\n\n\nStripTrailingSlash\n\n\nStripTrailingSlash middleware removes the trailing slash from request path.\n\n\nExample\n\n\ne.Use(mw.StripTrailingSlash())\n\n\n\n\nRedirectToSlash\n\n\nRedirectToSlash middleware redirects requests without trailing slash path to trailing\nslash path.\n\n\nOptions\n\n\nRedirectToSlashOptions struct {\n    Code int\n}\n\n\n\n\nExample\n\n\ne.Use(mw.RedirectToSlash())\n\n\n\n\n\n\nStripTrailingSlash and RedirectToSlash middleware should not be used together.\n\n\n\n\nExamples\n\n\nResponse\n\n\nJSON\n\n\ncontext.JSON(code int, v interface{}) error\n\n\n\n\nSends a JSON HTTP response with status code.\n\n\nString\n\n\ncontext.String(code int, s string) error\n\n\n\n\nSends a text/plain HTTP response with status code.\n\n\nHTML\n\n\nfunc (c *Context) HTML(code int, html string) error\n\n\n\n\nSends an HTML HTTP response with status code.\n\n\nStatic files\n\n\nEcho.Static(path, root string)\n serves static files. For example, code below serves\nfiles from directory \npublic/scripts\n for any request path starting with \n/scripts/\n.\n\n\ne.Static(\n/scripts/\n, \npublic/scripts\n)\n\n\n\n\nServing a file\n\n\nEcho.ServeFile(path, file string)\n serves a file. For example, code below serves\nfile \nwelcome.html\n for request path \n/welcome\n.\n\n\ne.ServeFile(\n/welcome\n, \nwelcome.html\n)\n\n\n\n\nServing an index file\n\n\nEcho.Index(file string)\n serves root index page - \nGET /\n. For example, code below\nserves root index page from file \npublic/index.html\n.\n\n\ne.Index(\npublic/index.html\n)\n\n\n\n\nServing favicon\n\n\nEcho.Favicon(file string)\n serves default favicon - \nGET /favicon.ico\n. For example,\ncode below serves favicon from file \npublic/favicon.ico\n.\n\n\ne.Favicon(\npublic/favicon.ico\n)\n\n\n\n\nError Handling\n\n\nEcho advocates centralized HTTP error handling by returning \nerror\n from middleware\nand handlers.\n\n\nIt allows you to\n\n\n\n\nDebug by writing stack trace to the HTTP response.\n\n\nCustomize HTTP responses.\n\n\nRecover from panics inside middleware or handlers.\n\n\n\n\nFor example, when basic auth middleware finds invalid credentials it returns\n\n401 - Unauthorized\n error, aborting the current HTTP request.\n\n\npackage main\n\nimport (\n    \nnet/http\n\n\n    \ngithub.com/labstack/echo\n\n)\n\nfunc main() {\n    e := echo.New()\n    e.Use(func(c *echo.Context) error {\n        // Extract the credentials from HTTP request header and perform a security\n        // check\n\n        // For invalid credentials\n        return echo.NewHTTPError(http.StatusUnauthorized)\n    })\n    e.Get(\n/welcome\n, welcome)\n    e.Run(\n:1323\n)\n}\n\nfunc welcome(c *echo.Context) error {\n    return c.String(http.StatusOK, \nWelcome!\n)\n}\n\n\n\n\nSee how \nHTTPErrorHandler\n handles it.\n\n\nDeployment\n\n\nWIP", 
            "title": "Guide"
        }, 
        {
            "location": "/guide/#guide", 
            "text": "", 
            "title": "Guide"
        }, 
        {
            "location": "/guide/#installation", 
            "text": "Echo has been developed and tested using Go  1.4.x  Install the latest version of Echo via  go get  $ go get github.com/labstack/echo  To upgrade  $ go get -u github.com/labstack/echo  Echo follows  semantic versioning  managed through GitHub releases.\nSpecific version of Echo can be installed using any  package manager .", 
            "title": "Installation"
        }, 
        {
            "location": "/guide/#customization", 
            "text": "HTTP error handler  Echo.SetHTTPErrorHandler(h HTTPErrorHandler)  Registers a custom  Echo.HTTPErrorHandler .  Default handler rules   If error is of type  Echo.HTTPError  it sends HTTP response with status code  HTTPError.Code \nand message  HTTPError.Message .  Else it sends  500 - Internal Server Error .  If debug mode is enabled, it uses  error.Error()  as status message.   Debug  Echo.SetDebug(on bool)  Enables debug mode.", 
            "title": "Customization"
        }, 
        {
            "location": "/guide/#routing", 
            "text": "Echo's router is  fast, optimized  and\nflexible. It's based on  radix tree \ndata structure which makes routing lookup really fast. It leverages sync pool  to reuse memory and achieve\nzero dynamic memory allocation with no GC overhead.  Routes can be registered by specifying HTTP method, path and a handler. For example,\ncode below registers a route for method  GET , path  /hello  and a handler which sends Hello!  HTTP response.  echo.Get( /hello , func(c *echo.Context) error {\n    return c.String(http.StatusOK,  Hello! )\n})  Echo's default handler is  func(*echo.Context) error  where  echo.Context \nprimarily holds HTTP request and response objects. Echo also has a support for other\ntypes of handlers.  Path parameter  Request path parameters can be extracted either by name  Echo.Context.Param(name string) string \nor by index  Echo.Context.P(i int) string . Getting parameter by index gives a\nslightly better performance.  echo.Get( /users/:id , func(c *echo.Context) error {\n    // By name\n    id := c.Param( id )\n\n    // By index\n    id := c.P(0)\n\n    return c.String(http.StatusOK, id)\n})  Match-any  Matches zero or more characters in the path. For example, pattern  /users/*  will\nmatch   /users/  /users/1  /users/1/files/1  /users/anything...   Path matching order   Static  Param  Match any   Example  e.Get( /users/:id , func(c *echo.Context) error {\n    return c.String(http.StatusOK,  /users/:id )\n})\n\ne.Get( /users/new , func(c *echo.Context) error {\n    return c.String(http.StatusOK,  /users/new )\n})\n\ne.Get( /users/1/files/* , func(c *echo.Context) error {\n    return c.String(http.StatusOK,  /users/1/files/* )\n})  Above routes would resolve in order   /users/new  /users/:id  /users/1/files/*   Routes can be written in any order.  Group  Echo.Group(prefix string, m ...Middleware) *Group  Routes with common prefix can be grouped to define a new sub-router with optional\nmiddleware. If middleware is passed to the function, it overrides parent middleware\n- helpful if you want a completely new middleware stack for the group. To add middleware\nlater you can use  Group.Use(m ...Middleware) . Groups can also be nested.  In the code below, we create an admin group which requires basic HTTP authentication\nfor routes  /admin/* .  echo.Group( /admin )\ne.Use(mw.BasicAuth(func(usr, pwd string) bool {\n    if usr ==  joe    pwd ==  secret  {\n        return true\n    }\n    return false\n}))  URI building  Echo.URI  can be used generate URI for any handler with specified path parameters.\nIt's helpful to centralize all your URI patterns which ease in refactoring your\napplication.  echo.URI(h, 1)  will generate  /users/1  for the route registered below  // Handler\nh := func(*echo.Context) error {\n    return c.String(http.StatusOK,  OK )\n}\n\n// Route\ne.Get( /users/:id , h)", 
            "title": "Routing"
        }, 
        {
            "location": "/guide/#middleware", 
            "text": "Middleware is function which is chained in the HTTP request-response cycle. Middleware\nhas access to the request and response objects which it utilizes to perform a specific\naction for example, logging every request. Echo supports variety of  middleware .  Logger  Logs each HTTP request with method, path, status, response time and bytes served.  Example  e.Use(Logger())\n\n// Output: `2015/06/07 18:16:16 GET / 200 13.238\u00b5s 14`  BasicAuth  BasicAuth middleware provides an HTTP basic authentication.   For valid credentials it calls the next handler in the chain.  For invalid Authorization header it sends \"404 - Bad Request\" response.  For invalid credentials, it sends \"401 - Unauthorized\" response.   Example  echo.Group( /admin )\ne.Use(mw.BasicAuth(func(usr, pwd string) bool {\n    if usr ==  joe    pwd ==  secret  {\n        return true\n    }\n    return false\n}))  Gzip  Gzip middleware compresses HTTP response using gzip compression scheme.  Example  e.Use(mw.Gzip())  Recover  Recover middleware recovers from panics anywhere in the chain and handles the control\nto the centralized  HTTPErrorHandler .  Example  e.Use(mw.Recover())  StripTrailingSlash  StripTrailingSlash middleware removes the trailing slash from request path.  Example  e.Use(mw.StripTrailingSlash())  RedirectToSlash  RedirectToSlash middleware redirects requests without trailing slash path to trailing\nslash path.  Options  RedirectToSlashOptions struct {\n    Code int\n}  Example  e.Use(mw.RedirectToSlash())   StripTrailingSlash and RedirectToSlash middleware should not be used together.   Examples", 
            "title": "Middleware"
        }, 
        {
            "location": "/guide/#response", 
            "text": "JSON  context.JSON(code int, v interface{}) error  Sends a JSON HTTP response with status code.  String  context.String(code int, s string) error  Sends a text/plain HTTP response with status code.  HTML  func (c *Context) HTML(code int, html string) error  Sends an HTML HTTP response with status code.  Static files  Echo.Static(path, root string)  serves static files. For example, code below serves\nfiles from directory  public/scripts  for any request path starting with  /scripts/ .  e.Static( /scripts/ ,  public/scripts )  Serving a file  Echo.ServeFile(path, file string)  serves a file. For example, code below serves\nfile  welcome.html  for request path  /welcome .  e.ServeFile( /welcome ,  welcome.html )  Serving an index file  Echo.Index(file string)  serves root index page -  GET / . For example, code below\nserves root index page from file  public/index.html .  e.Index( public/index.html )  Serving favicon  Echo.Favicon(file string)  serves default favicon -  GET /favicon.ico . For example,\ncode below serves favicon from file  public/favicon.ico .  e.Favicon( public/favicon.ico )", 
            "title": "Response"
        }, 
        {
            "location": "/guide/#error-handling", 
            "text": "Echo advocates centralized HTTP error handling by returning  error  from middleware\nand handlers.  It allows you to   Debug by writing stack trace to the HTTP response.  Customize HTTP responses.  Recover from panics inside middleware or handlers.   For example, when basic auth middleware finds invalid credentials it returns 401 - Unauthorized  error, aborting the current HTTP request.  package main\n\nimport (\n     net/http \n\n     github.com/labstack/echo \n)\n\nfunc main() {\n    e := echo.New()\n    e.Use(func(c *echo.Context) error {\n        // Extract the credentials from HTTP request header and perform a security\n        // check\n\n        // For invalid credentials\n        return echo.NewHTTPError(http.StatusUnauthorized)\n    })\n    e.Get( /welcome , welcome)\n    e.Run( :1323 )\n}\n\nfunc welcome(c *echo.Context) error {\n    return c.String(http.StatusOK,  Welcome! )\n}  See how  HTTPErrorHandler  handles it.", 
            "title": "Error Handling"
        }, 
        {
            "location": "/guide/#deployment", 
            "text": "WIP", 
            "title": "Deployment"
        }, 
        {
            "location": "/recipes/file-upload/", 
            "text": "File Upload\n\n\n\n\nMultipart/form-data file upload\n\n\nMultiple form fields and files\n\n\n\n\nUse \nreq.ParseMultipartForm(16 \n 20)\n for manually parsing multipart form. It gives\nus an option to specify the maximum memory used while parsing the request body. \n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nio\n\n    \nos\n\n\n    \nnet/http\n\n\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n)\n\nfunc upload(c *echo.Context) error {\n    req := c.Request()\n\n    // req.ParseMultipartForm(16 \n 20) // Max memory 16 MiB\n\n    // Read form fields\n    name := req.FormValue(\nname\n)\n    email := req.FormValue(\nemail\n)\n\n    // Read files\n    files := req.MultipartForm.File[\nfiles\n]\n    for _, f := range files {\n        // Source file\n        src, err := f.Open()\n        if err != nil {\n            return err\n        }\n        defer src.Close()\n\n        // Destination file\n        dst, err := os.Create(f.Filename)\n        if err != nil {\n            return err\n        }\n        defer dst.Close()\n\n        if _, err = io.Copy(dst, src); err != nil {\n            return err\n        }\n    }\n    return c.String(http.StatusOK, \nThank You! %s \n%s\n, %d files uploaded successfully.\n,\n        name, email, len(files))\n}\n\nfunc main() {\n    e := echo.New()\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static(\n/\n, \npublic\n)\n    e.Post(\n/upload\n, upload)\n\n    e.Run(\n:1323\n)\n}\n\n\n\n\nindex.html\n\n\n!doctype html\n\n\nhtml lang=\nen\n\n\nhead\n\n    \nmeta charset=\nutf-8\n\n    \ntitle\nFile Upload\n/title\n\n\n/head\n\n\nbody\n\n    \nh1\nUpload Files\n/h1\n\n    \nform action=\n/upload\n method=\npost\n enctype=\nmultipart/form-data\n\n        Name: \ninput type=\ntext\n name=\nname\nbr\n\n        Email: \ninput type=\nemail\n name=\nemail\nbr\n\n        Files: \ninput type=\nfile\n name=\nfiles\n multiple\nbr\nbr\n\n        \ninput type=\nsubmit\n value=\nSubmit\n\n    \n/form\n\n\n/body\n\n\n/html\n\n\n\n\n\n\nSource Code", 
            "title": "File Upload"
        }, 
        {
            "location": "/recipes/file-upload/#file-upload", 
            "text": "Multipart/form-data file upload  Multiple form fields and files   Use  req.ParseMultipartForm(16   20)  for manually parsing multipart form. It gives\nus an option to specify the maximum memory used while parsing the request body.   server.go  package main\n\nimport (\n     io \n     os \n\n     net/http \n\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n)\n\nfunc upload(c *echo.Context) error {\n    req := c.Request()\n\n    // req.ParseMultipartForm(16   20) // Max memory 16 MiB\n\n    // Read form fields\n    name := req.FormValue( name )\n    email := req.FormValue( email )\n\n    // Read files\n    files := req.MultipartForm.File[ files ]\n    for _, f := range files {\n        // Source file\n        src, err := f.Open()\n        if err != nil {\n            return err\n        }\n        defer src.Close()\n\n        // Destination file\n        dst, err := os.Create(f.Filename)\n        if err != nil {\n            return err\n        }\n        defer dst.Close()\n\n        if _, err = io.Copy(dst, src); err != nil {\n            return err\n        }\n    }\n    return c.String(http.StatusOK,  Thank You! %s  %s , %d files uploaded successfully. ,\n        name, email, len(files))\n}\n\nfunc main() {\n    e := echo.New()\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static( / ,  public )\n    e.Post( /upload , upload)\n\n    e.Run( :1323 )\n}  index.html  !doctype html  html lang= en  head \n     meta charset= utf-8 \n     title File Upload /title  /head  body \n     h1 Upload Files /h1 \n     form action= /upload  method= post  enctype= multipart/form-data \n        Name:  input type= text  name= name br \n        Email:  input type= email  name= email br \n        Files:  input type= file  name= files  multiple br br \n         input type= submit  value= Submit \n     /form  /body  /html", 
            "title": "File Upload"
        }, 
        {
            "location": "/recipes/file-upload/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/streaming-file-upload/", 
            "text": "Streaming File Upload\n\n\n\n\nStreaming multipart/form-data file upload\n\n\nMultiple form fields and files\n\n\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nio/ioutil\n\n\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n    \nio\n\n    \nnet/http\n\n    \nos\n\n)\n\nfunc upload(c *echo.Context) error {\n    mr, err := c.Request().MultipartReader()\n    if err != nil {\n        return err\n    }\n\n    // Read form field `name`\n    part, err := mr.NextPart()\n    if err != nil {\n        return err\n    }\n    defer part.Close()\n    b, err := ioutil.ReadAll(part)\n    if err != nil {\n        return err\n    }\n    name := string(b)\n\n    // Read form field `email`\n    part, err = mr.NextPart()\n    if err != nil {\n        return err\n    }\n    defer part.Close()\n    b, err = ioutil.ReadAll(part)\n    if err != nil {\n        return err\n    }\n    email := string(b)\n\n    // Read files\n    i := 0\n    for {\n        part, err := mr.NextPart()\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return err\n        }\n        defer part.Close()\n\n        file, err := os.Create(part.FileName())\n        if err != nil {\n            return err\n        }\n        defer file.Close()\n\n        if _, err := io.Copy(file, part); err != nil {\n            return err\n        }\n        i++\n    }\n    return c.String(http.StatusOK, \nThank You! %s \n%s\n, %d files uploaded successfully.\n,\n        name, email, i)\n}\n\nfunc main() {\n    e := echo.New()\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static(\n/\n, \npublic\n)\n    e.Post(\n/upload\n, upload)\n\n    e.Run(\n:1323\n)\n}\n\n\n\n\nindex.html\n\n\n!doctype html\n\n\nhtml lang=\nen\n\n\nhead\n\n    \nmeta charset=\nutf-8\n\n    \ntitle\nFile Upload\n/title\n\n\n/head\n\n\nbody\n\n    \nh1\nUpload Files\n/h1\n\n    \nform action=\n/upload\n method=\npost\n enctype=\nmultipart/form-data\n\n        Name: \ninput type=\ntext\n name=\nname\nbr\n\n        Email: \ninput type=\nemail\n name=\nemail\nbr\n\n        Files: \ninput type=\nfile\n name=\nfiles\n multiple\nbr\nbr\n\n        \ninput type=\nsubmit\n value=\nSubmit\n\n    \n/form\n\n\n/body\n\n\n/html\n\n\n\n\n\n\nSource Code", 
            "title": "Streaming File Upload"
        }, 
        {
            "location": "/recipes/streaming-file-upload/#streaming-file-upload", 
            "text": "Streaming multipart/form-data file upload  Multiple form fields and files   server.go  package main\n\nimport (\n     io/ioutil \n\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n     io \n     net/http \n     os \n)\n\nfunc upload(c *echo.Context) error {\n    mr, err := c.Request().MultipartReader()\n    if err != nil {\n        return err\n    }\n\n    // Read form field `name`\n    part, err := mr.NextPart()\n    if err != nil {\n        return err\n    }\n    defer part.Close()\n    b, err := ioutil.ReadAll(part)\n    if err != nil {\n        return err\n    }\n    name := string(b)\n\n    // Read form field `email`\n    part, err = mr.NextPart()\n    if err != nil {\n        return err\n    }\n    defer part.Close()\n    b, err = ioutil.ReadAll(part)\n    if err != nil {\n        return err\n    }\n    email := string(b)\n\n    // Read files\n    i := 0\n    for {\n        part, err := mr.NextPart()\n        if err != nil {\n            if err == io.EOF {\n                break\n            }\n            return err\n        }\n        defer part.Close()\n\n        file, err := os.Create(part.FileName())\n        if err != nil {\n            return err\n        }\n        defer file.Close()\n\n        if _, err := io.Copy(file, part); err != nil {\n            return err\n        }\n        i++\n    }\n    return c.String(http.StatusOK,  Thank You! %s  %s , %d files uploaded successfully. ,\n        name, email, i)\n}\n\nfunc main() {\n    e := echo.New()\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static( / ,  public )\n    e.Post( /upload , upload)\n\n    e.Run( :1323 )\n}  index.html  !doctype html  html lang= en  head \n     meta charset= utf-8 \n     title File Upload /title  /head  body \n     h1 Upload Files /h1 \n     form action= /upload  method= post  enctype= multipart/form-data \n        Name:  input type= text  name= name br \n        Email:  input type= email  name= email br \n        Files:  input type= file  name= files  multiple br br \n         input type= submit  value= Submit \n     /form  /body  /html", 
            "title": "Streaming File Upload"
        }, 
        {
            "location": "/recipes/streaming-file-upload/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/streaming-response/", 
            "text": "Streaming Response\n\n\n\n\nSend data as it is produced\n\n\nStreaming JSON response with chunked transfer encoding\n\n\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nnet/http\n\n    \ntime\n\n\n    \nencoding/json\n\n\n    \ngithub.com/labstack/echo\n\n)\n\ntype (\n    Geolocation struct {\n        Altitude  float64\n        Latitude  float64\n        Longitude float64\n    }\n)\n\nvar (\n    locations = []Geolocation{\n        {-97, 37.819929, -122.478255},\n        {1899, 39.096849, -120.032351},\n        {2619, 37.865101, -119.538329},\n        {42, 33.812092, -117.918974},\n        {15, 37.77493, -122.419416},\n    }\n)\n\nfunc main() {\n    e := echo.New()\n    e.Get(\n/\n, func(c *echo.Context) error {\n        c.Response().Header().Set(echo.ContentType, echo.ApplicationJSON)\n        c.Response().WriteHeader(http.StatusOK)\n        for _, l := range locations {\n            if err := json.NewEncoder(c.Response()).Encode(l); err != nil {\n                return err\n            }\n            c.Response().Flush()\n            time.Sleep(1 * time.Second)\n        }\n        return nil\n    })\n    e.Run(\n:1323\n)\n}\n\n\n\n\ncurl localhost:1323\n\n\n{\nAltitude\n:-97,\nLatitude\n:37.819929,\nLongitude\n:-122.478255}\n{\nAltitude\n:1899,\nLatitude\n:39.096849,\nLongitude\n:-120.032351}\n{\nAltitude\n:2619,\nLatitude\n:37.865101,\nLongitude\n:-119.538329}\n{\nAltitude\n:42,\nLatitude\n:33.812092,\nLongitude\n:-117.918974}\n{\nAltitude\n:15,\nLatitude\n:37.77493,\nLongitude\n:-122.419416}\n\n\n\n\nSource Code", 
            "title": "Streaming Response"
        }, 
        {
            "location": "/recipes/streaming-response/#streaming-response", 
            "text": "Send data as it is produced  Streaming JSON response with chunked transfer encoding   server.go  package main\n\nimport (\n     net/http \n     time \n\n     encoding/json \n\n     github.com/labstack/echo \n)\n\ntype (\n    Geolocation struct {\n        Altitude  float64\n        Latitude  float64\n        Longitude float64\n    }\n)\n\nvar (\n    locations = []Geolocation{\n        {-97, 37.819929, -122.478255},\n        {1899, 39.096849, -120.032351},\n        {2619, 37.865101, -119.538329},\n        {42, 33.812092, -117.918974},\n        {15, 37.77493, -122.419416},\n    }\n)\n\nfunc main() {\n    e := echo.New()\n    e.Get( / , func(c *echo.Context) error {\n        c.Response().Header().Set(echo.ContentType, echo.ApplicationJSON)\n        c.Response().WriteHeader(http.StatusOK)\n        for _, l := range locations {\n            if err := json.NewEncoder(c.Response()).Encode(l); err != nil {\n                return err\n            }\n            c.Response().Flush()\n            time.Sleep(1 * time.Second)\n        }\n        return nil\n    })\n    e.Run( :1323 )\n}  curl localhost:1323  { Altitude :-97, Latitude :37.819929, Longitude :-122.478255}\n{ Altitude :1899, Latitude :39.096849, Longitude :-120.032351}\n{ Altitude :2619, Latitude :37.865101, Longitude :-119.538329}\n{ Altitude :42, Latitude :33.812092, Longitude :-117.918974}\n{ Altitude :15, Latitude :37.77493, Longitude :-122.419416}", 
            "title": "Streaming Response"
        }, 
        {
            "location": "/recipes/streaming-response/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/websocket/", 
            "text": "WebSocket\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n    \ngolang.org/x/net/websocket\n\n)\n\nfunc main() {\n    e := echo.New()\n\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static(\n/\n, \npublic\n)\n    e.WebSocket(\n/ws\n, func(c *echo.Context) (err error) {\n        ws := c.Socket()\n        msg := \n\n\n        for {\n            if err = websocket.Message.Send(ws, \nHello, Client!\n); err != nil {\n                return\n            }\n            if err = websocket.Message.Receive(ws, \nmsg); err != nil {\n                return\n            }\n            println(msg)\n        }\n        return\n    })\n\n    e.Run(\n:1323\n)\n}\n\n\n\n\nindex.html\n\n\n!doctype html\n\n\nhtml lang=\nen\n\n\nhead\n\n    \nmeta charset=\nutf-8\n\n    \ntitle\nWebSocket\n/title\n\n\n/head\n\n\nbody\n\n    \np id=\noutput\n/p\n\n\n    \nscript\n\n        var loc = window.location;\n        var uri = 'ws:';\n        var start;\n\n        if (loc.protocol === 'https:') {\n            uri = 'wss:';\n        }\n        uri += '//' + loc.host;\n        uri += loc.pathname + 'ws';\n\n        ws = new WebSocket(uri)\n\n        ws.onopen = function() {\n            console.log('Connected')\n        }\n\n        ws.onmessage = function(evt) {\n            var out = document.getElementById('output');\n            out.innerHTML += evt.data + '\nbr\n';\n        }\n\n        setInterval(function() {\n            start = new Date().getTime();\n            ws.send('Hello, Server!');\n        }, 1000);\n    \n/script\n\n\n/body\n\n\n/html\n\n\n\n\n\nSource Code", 
            "title": "WebSocket"
        }, 
        {
            "location": "/recipes/websocket/#websocket", 
            "text": "server.go  package main\n\nimport (\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n     golang.org/x/net/websocket \n)\n\nfunc main() {\n    e := echo.New()\n\n    e.Use(mw.Logger())\n    e.Use(mw.Recover())\n\n    e.Static( / ,  public )\n    e.WebSocket( /ws , func(c *echo.Context) (err error) {\n        ws := c.Socket()\n        msg :=  \n\n        for {\n            if err = websocket.Message.Send(ws,  Hello, Client! ); err != nil {\n                return\n            }\n            if err = websocket.Message.Receive(ws,  msg); err != nil {\n                return\n            }\n            println(msg)\n        }\n        return\n    })\n\n    e.Run( :1323 )\n}  index.html  !doctype html  html lang= en  head \n     meta charset= utf-8 \n     title WebSocket /title  /head  body \n     p id= output /p \n\n     script \n        var loc = window.location;\n        var uri = 'ws:';\n        var start;\n\n        if (loc.protocol === 'https:') {\n            uri = 'wss:';\n        }\n        uri += '//' + loc.host;\n        uri += loc.pathname + 'ws';\n\n        ws = new WebSocket(uri)\n\n        ws.onopen = function() {\n            console.log('Connected')\n        }\n\n        ws.onmessage = function(evt) {\n            var out = document.getElementById('output');\n            out.innerHTML += evt.data + ' br ';\n        }\n\n        setInterval(function() {\n            start = new Date().getTime();\n            ws.send('Hello, Server!');\n        }, 1000);\n     /script  /body  /html", 
            "title": "WebSocket"
        }, 
        {
            "location": "/recipes/websocket/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/subdomains/", 
            "text": "Subdomains\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nnet/http\n\n\n    \ngithub.com/labstack/echo\n\n    mw \ngithub.com/labstack/echo/middleware\n\n)\n\ntype Hosts map[string]http.Handler\n\nfunc (h Hosts) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if handler := h[r.Host]; handler != nil {\n        handler.ServeHTTP(w, r)\n    } else {\n        http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n    }\n}\n\nfunc main() {\n    // Host map\n    hosts := make(Hosts)\n\n    //-----\n    // API\n    //-----\n\n    api := echo.New()\n    api.Use(mw.Logger())\n    api.Use(mw.Recover())\n\n    hosts[\napi.localhost:1323\n] = api\n\n    api.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nAPI\n)\n    })\n\n    //------\n    // Blog\n    //------\n\n    blog := echo.New()\n    blog.Use(mw.Logger())\n    blog.Use(mw.Recover())\n\n    hosts[\nblog.localhost:1323\n] = blog\n\n    blog.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nBlog\n)\n    })\n\n    //---------\n    // Website\n    //---------\n\n    site := echo.New()\n    site.Use(mw.Logger())\n    site.Use(mw.Recover())\n\n    hosts[\nlocalhost:1323\n] = site\n\n    site.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nWelcome!\n)\n    })\n\n    http.ListenAndServe(\n:1323\n, hosts)\n}\n\n\n\n\nSource Code", 
            "title": "Subdomains"
        }, 
        {
            "location": "/recipes/subdomains/#subdomains", 
            "text": "server.go  package main\n\nimport (\n     net/http \n\n     github.com/labstack/echo \n    mw  github.com/labstack/echo/middleware \n)\n\ntype Hosts map[string]http.Handler\n\nfunc (h Hosts) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if handler := h[r.Host]; handler != nil {\n        handler.ServeHTTP(w, r)\n    } else {\n        http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)\n    }\n}\n\nfunc main() {\n    // Host map\n    hosts := make(Hosts)\n\n    //-----\n    // API\n    //-----\n\n    api := echo.New()\n    api.Use(mw.Logger())\n    api.Use(mw.Recover())\n\n    hosts[ api.localhost:1323 ] = api\n\n    api.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  API )\n    })\n\n    //------\n    // Blog\n    //------\n\n    blog := echo.New()\n    blog.Use(mw.Logger())\n    blog.Use(mw.Recover())\n\n    hosts[ blog.localhost:1323 ] = blog\n\n    blog.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  Blog )\n    })\n\n    //---------\n    // Website\n    //---------\n\n    site := echo.New()\n    site.Use(mw.Logger())\n    site.Use(mw.Recover())\n\n    hosts[ localhost:1323 ] = site\n\n    site.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  Welcome! )\n    })\n\n    http.ListenAndServe( :1323 , hosts)\n}", 
            "title": "Subdomains"
        }, 
        {
            "location": "/recipes/subdomains/#source-code", 
            "text": "", 
            "title": "Source Code"
        }, 
        {
            "location": "/recipes/graceful-shutdown/", 
            "text": "Graceful Shutdown\n\n\nWith \ngraceful\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nnet/http\n\n    \ntime\n\n\n    \ngithub.com/labstack/echo\n\n    \ngithub.com/tylerb/graceful\n\n)\n\nfunc main() {\n    // Setup\n    e := echo.New()\n    e.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nSue sews rose on slow jor crows nose\n)\n    })\n\n    graceful.ListenAndServe(e.Server(\n:1323\n), 5*time.Second)\n}\n\n\n\n\nWith \ngrace\n\n\nserver.go\n\n\npackage main\n\nimport (\n    \nnet/http\n\n\n    \ngithub.com/facebookgo/grace/gracehttp\n\n    \ngithub.com/labstack/echo\n\n)\n\nfunc main() {\n    // Setup\n    e := echo.New()\n    e.Get(\n/\n, func(c *echo.Context) error {\n        return c.String(http.StatusOK, \nSix sick bricks tick\n)\n    })\n\n    gracehttp.Serve(e.Server(\n:1323\n))\n}\n\n\n\n\nSource Code\n\n\ngraceful\n\n\ngrace", 
            "title": "Graceful Shutdown"
        }, 
        {
            "location": "/recipes/graceful-shutdown/#graceful-shutdown", 
            "text": "With  graceful  server.go  package main\n\nimport (\n     net/http \n     time \n\n     github.com/labstack/echo \n     github.com/tylerb/graceful \n)\n\nfunc main() {\n    // Setup\n    e := echo.New()\n    e.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  Sue sews rose on slow jor crows nose )\n    })\n\n    graceful.ListenAndServe(e.Server( :1323 ), 5*time.Second)\n}  With  grace  server.go  package main\n\nimport (\n     net/http \n\n     github.com/facebookgo/grace/gracehttp \n     github.com/labstack/echo \n)\n\nfunc main() {\n    // Setup\n    e := echo.New()\n    e.Get( / , func(c *echo.Context) error {\n        return c.String(http.StatusOK,  Six sick bricks tick )\n    })\n\n    gracehttp.Serve(e.Server( :1323 ))\n}", 
            "title": "Graceful Shutdown"
        }, 
        {
            "location": "/recipes/graceful-shutdown/#source-code", 
            "text": "graceful  grace", 
            "title": "Source Code"
        }
    ]
}